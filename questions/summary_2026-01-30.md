# Ringkasan Tanya Jawab (30 Januari 2026)

Berikut adalah rangkuman pertanyaan dan solusi yang dibahas dalam 3 hari terakhir (khususnya hari ini).

---

## üèóÔ∏è Topik: Concurrency & Mental Model

### 1. Go Routine vs Javascript Hoisting
**Q:** *"Apakah ada mekanisme hoisting pada go routine seperti di JS (V8 Stack)? Apakah program tetap membaca dari atas ke bawah?"*

**A:** 
- **Tidak ada Hoisting.** Go membaca kode secara sekuensial (atas ke bawah).
- Saat bertemu keyword `go`, runtime melakukan **"Percabangan Jalan"** (Spawn Thread) lalu *langsung lanjut* ke baris berikutnya tanpa menunggu.
- Mental Model: Bukan "diangkat ke atas", tapi "dilempar ke jalur samping".

### 2. Main Branch & Stack
**Q:** *"Apakah scheduler menyambung kembali ke main branch? Apakah semua stack dijadikan satu?"*

**A:** 
- **Tidak.** Setiap Goroutine punya **Stack Sendiri (2KB)** yang terpisah.
- Main Goroutine **TIDAK PEDULI** dengan anak-anaknya. Jika Main selesai, program mati (Exit), semua anak dipaksa berhenti.
- Kita butuh "Lem Perekat" manual seperti `WaitGroup` atau `Channel` agar Main mau menunggu.

### 3. Isi Stack Goroutine
**Q:** *"Apa isi stack goroutine A (2KB) ntu? Apakah kode program itu sendiri?"*

**A:** 
- **Bukan.** Kode program (instruksi/logic) dismpan di *Shared Memory* (Text Segment) dan dibaca ramai-ramai.
- **Stack 2KB berisi State Pribadi:** Variabel lokal, Parameter fungsi, dan *Return Address* (Catatan mau pulang ke baris mana).

---

## üö¶ Topik: Real World Implementation

### 4. Kapan Pakai "Ribuan Goroutine" vs "Limited Worker"?
**Q:** *"Konsep ribuan goroutine tidak masuk akal bagi saya. Kapan pakai ribuan dan kapan limited?"*

**A:** Lihat **Sifat Pekerjaan (Workload)**:
1.  **IO Bound (Banyak Nunggu):** Gunakan **Ribuan Goroutine**.
    - Contoh: Request API, Query Database, Kirim Notifikasi, gRPC Call, RabbitMQ Consumer.
    - Kenapa: CPU nganggur saat menunggu network. Sayang kalau dibatasi.
2.  **CPU Bound (Banyak Mikir):** Gunakan **Limited Worker Pool (Sejumlah Core CPU)**.
    - Contoh: Resize Gambar, Video Transcoding, Hashing.
    - Kenapa: Kalau berlebihan, CPU stress gonta-ganti konteks (Context Switching).
3.  **Resource Constraint:** Gunakan **Limited Worker Pool (Sejumlah Limit Resource)**.
    - Contoh: Migrasi ke DB Tua (Max Conn = 100).
    - Kenapa: Demi melindungi sistem tujuan agar tidak meledak/crash.

### 5. Inbound/Outbound IO Bound
**Q:** *"Apakah request ke 100 API berbeda termasuk IO Bound? Bagaimana dengan gRPC/RabbitMQ?"*

**A:**
- **YA, Semuanya IO Bound.**
- **Outbound:** Hit 1 API 100x atau hit 100 API berbeda, sama saja. CPU kita "Menunggu" response dari luar.
- **gRPC:** Sama seperti HTTP, ini network call. Sangat IO Bound.
- **Message Queue (Kafka/RabbitMQ):**
    - **Consumer:** Sangat wajib pakai Goroutine. Jika antrian ada 1 juta pesan, dan kita cuma pakai 1 consumer (sequential), antrian akan macet. Kita perlu spawn banyak consumer worker (Goroutine) untuk memproses pesan secara paralel.
    - **Producer:** Publish message ke Kafka juga IO Bound (nunggu ACK dari broker).

### 6. Mental Model: IO Bound Case
**Q:** *"Skenario paling sering/90% untuk IO bound adalah hit api?"*

**A:**
- **YA (90%++):** Network Calls (HTTP, gRPC, DB Query).
- **Sisanya:** Disk Operations (Baca File besar), User Input (Nunggu user ngetik).

### 7. Code Implementation
**Q:** *"Tolong buatkan code real jangan pakai time.Sleep"*

**A:** Implementasi Real World (`http.Get` untuk IO, `Recursive Fib` untuk CPU) sudah dibuatkan di file:
`test/specific/real_world_scenarios.go`

---

## üõ†Ô∏è Teknis Go

### 8. Fungsi `io.Copy(io.Discard, resp.Body)`
**Q:** *"Apa fungsi baris ini?"*

**A:** 
- Untuk **Menguras Sisa Response Body** sampai kering.
- Tujuannya agar koneksi TCP (pipa) bersih dan bisa **dipakai ulang** (Connection Reuse/Keep-Alive) untuk request berikutnya.
- Tanpa ini, koneksi akan dibuang paksa (boros resource).

---
*Generated pada: 2026-01-30*
