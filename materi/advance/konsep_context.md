# Context dalam Golang\n\nPackage `context` dalam Go menyediakan API untuk mengirim sinyal pembatalan, batas waktu (deadline), dan data lintas batas API dan antar proses. Context sangat penting dalam aplikasi concurrent dan server-side programming untuk manajemen lifetime request dan sumber daya.\n\n## 1. Dasar Context\n\n### a. Konsep\nContext digunakan untuk:\n1. **Pembatalan (Cancellation)**: Memberitahu goroutine bahwa operasi harus dihentikan.\n2. **Deadline**: Menetapkan batas waktu untuk operasi.\n3. **Timeout**: Menetapkan durasi maksimum untuk operasi.\n4. **Value passing**: Mengirim data request-scoped antar komponen.\n\n### b. Jenis Context\n- `context.Background()`: Context kosong sebagai root untuk graph context.\n- `context.TODO()`: Placeholder untuk context yang akan ditambahkan nanti.\n\n### c. Fungsi Pembentuk Context\n- `WithCancel(parent Context)`: Membuat context yang bisa dibatalkan.\n- `WithDeadline(parent Context, d time.Time)`: Membuat context dengan deadline spesifik.\n- `WithTimeout(parent Context, timeout time.Duration)`: Membuat context dengan timeout.\n- `WithValue(parent Context, key, val interface{})`: Membuat context dengan pasangan key-value.\n\n## 2. Mekanisme dan Perilaku\n\n### a. Pembatalan dengan context.WithCancel\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc longRunningTask(ctx context.Context, taskName string) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Printf(\"Task %s cancelled: %v\\n\", taskName, ctx.Err())\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Printf(\"Task %s is working...\\n\", taskName)\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Membuat context yang bisa dibatalkan\n\tctx, cancel := context.WithCancel(context.Background())\n\t\n\t// Menjalankan dua goroutine\n\tgo longRunningTask(ctx, \"Task-1\")\n\tgo longRunningTask(ctx, \"Task-2\")\n\t\n\t// Menunggu 2 detik\n\ttime.Sleep(2 * time.Second)\n\t\n\t// Membatalkan context\n\tfmt.Println(\"Cancelling all tasks...\")\n\tcancel()\n\t\n\t// Memberi waktu untuk melihat hasil pembatalan\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"Main finished\")\n}\n```\n\n**Hasil:**\n```\nTask Task-1 is working...\nTask Task-2 is working...\nTask Task-1 is working...\nTask Task-2 is working...\nTask Task-1 is working...\nTask Task-2 is working...\nTask Task-1 is working...\nTask Task-2 is working...\nCancelling all tasks...\nTask Task-1 cancelled: context canceled\nTask Task-2 cancelled: context canceled\nMain finished\n```\n\n### b. Timeout dengan context.WithTimeout\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc databaseQuery(ctx context.Context) error {\n\t// Simulasi query database yang lama\n\tselect {\n\tcase <-time.After(3 * time.Second):\n\t\treturn fmt.Errorf(\"database query completed\")\n\tcase <-ctx.Done():\n\t\treturn ctx.Err() // Mengembalikan error timeout\n\t}\n}\n\nfunc main() {\n\t// Membuat context dengan timeout 2 detik\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel() // Pastikan cancel dipanggil\n\t\n\tfmt.Println(\"Starting database query...\")\n\t\n\t// Memanggil fungsi dengan context\n\terr := databaseQuery(ctx)\n\tif err != nil {\n\t\tfmt.Printf(\"Query failed: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(\"Query succeeded\")\n\t}\n}\n```\n\n**Hasil:**\n```\nStarting database query...\nQuery failed: context deadline exceeded\n```\n\n### c. Deadline dengan context.WithDeadline\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc fileProcessing(ctx context.Context) error {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tfmt.Println(\"Processing file...\")\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Menetapkan deadline 3 detik dari sekarang\n\tdeadline := time.Now().Add(3 * time.Second)\n\tctx, cancel := context.WithDeadline(context.Background(), deadline)\n\tdefer cancel()\n\t\n\tfmt.Println(\"Starting file processing...\")\n\t\n\terr := fileProcessing(ctx)\n\tif err != nil {\n\t\tfmt.Printf(\"Processing failed: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(\"Processing completed\")\n\t}\n}\n```\n\n**Hasil:**\n```\nStarting file processing...\nProcessing file...\nProcessing file...\nProcessing file...\nProcessing failed: context deadline exceeded\n```\n\n## 3. Passing Value dengan Context\n\n### a. Dasar Value Passing\nContext bisa digunakan untuk passing data request-scoped seperti user ID, request ID, dll.\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\ntype key string\n\nconst (\n\tUserIDKey key = \"userID\"\n\tRoleKey   key = \"role\"\n)\n\nfunc processRequest(ctx context.Context) {\n\t// Mengambil value dari context\n\tif userID, ok := ctx.Value(UserIDKey).(int); ok {\n\t\tfmt.Printf(\"Processing request for user ID: %d\\n\", userID)\n\t}\n\t\n\tif role, ok := ctx.Value(RoleKey).(string); ok {\n\t\tfmt.Printf(\"User role: %s\\n\", role)\n\t}\n\t\n\t// Memanggil fungsi lain dengan context yang sama\n\tperformAction(ctx)\n}\n\nfunc performAction(ctx context.Context) {\n\tif userID, ok := ctx.Value(UserIDKey).(int); ok {\n\t\tfmt.Printf(\"Performing action for user ID: %d\\n\", userID)\n\t}\n}\n\nfunc main() {\n\t// Membuat context dengan value\n\tctx := context.Background()\n\tctx = context.WithValue(ctx, UserIDKey, 123)\n\tctx = context.WithValue(ctx, RoleKey, \"admin\")\n\t\n\tprocessRequest(ctx)\n}\n```\n\n**Hasil:**\n```\nProcessing request for user ID: 123\nUser role: admin\nPerforming action for user ID: 123\n```\n\n### b. Best Practices untuk Value Passing\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// Mendefinisikan tipe key untuk menghindari collision\ntype contextKey string\n\nconst (\n\tRequestIDKey contextKey = \"requestID\"\n\tSessionIDKey contextKey = \"sessionID\"\n)\n\n// Fungsi helper untuk mengambil value dengan type assertion yang aman\nfunc GetRequestID(ctx context.Context) (string, bool) {\n\trequestID, ok := ctx.Value(RequestIDKey).(string)\n\treturn requestID, ok\n}\n\nfunc GetSessionID(ctx context.Context) (string, bool) {\n\tsessionID, ok := ctx.Value(SessionIDKey).(string)\n\treturn sessionID, ok\n}\n\nfunc handleRequest(ctx context.Context) {\n\tif requestID, ok := GetRequestID(ctx); ok {\n\t\tfmt.Printf(\"Handling request: %s\\n\", requestID)\n\t}\n\t\n\tif sessionID, ok := GetSessionID(ctx); ok {\n\t\tfmt.Printf(\"Session ID: %s\\n\", sessionID)\n\t}\n}\n\nfunc main() {\n\t// Membuat context dengan value\n\tctx := context.Background()\n\tctx = context.WithValue(ctx, RequestIDKey, \"req-12345\")\n\tctx = context.WithValue(ctx, SessionIDKey, \"sess-67890\")\n\t\n\thandleRequest(ctx)\n}\n```\n\n## 4. Context dalam HTTP Server\n\n### a. Integrasi dengan HTTP Handler\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc timeoutMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Membuat context dengan timeout 5 detik\n\t\tctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)\n\t\tdefer cancel()\n\t\t\n\t\t// Membuat request baru dengan context\n\t\tr = r.WithContext(ctx)\n\t\t\n\t\t// Menjalankan handler berikutnya dengan context timeout\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc slowHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Println(\"Starting slow operation...\")\n\t\n\t// Simulasi operasi lambat\n\tselect {\n\tcase <-time.After(10 * time.Second):\n\t\tfmt.Fprintln(w, \"Operation completed\")\n\tcase <-r.Context().Done():\n\t\t// Context dibatalkan (timeout)\n\t\tfmt.Printf(\"Request cancelled: %v\\n\", r.Context().Err())\n\t\thttp.Error(w, \"Request timeout\", http.StatusRequestTimeout)\n\t\treturn\n\t}\n}\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/slow\", slowHandler)\n\t\n\t// Menerapkan middleware timeout\n\tserver := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: timeoutMiddleware(mux),\n\t}\n\t\n\tfmt.Println(\"Server starting on :8080...\")\n\tif err := server.ListenAndServe(); err != nil {\n\t\tfmt.Printf(\"Server failed to start: %v\\n\", err)\n\t}\n}\n```\n\nUntuk menguji server ini:\n1. Jalankan program\n2. Buka browser dan akses `http://localhost:8080/slow`\n3. Setelah 5 detik, akan muncul error \"Request timeout\"\n\n## 5. Perilaku dan Gotchas\n\n### a. Context Harus Diteruskan, Bukan Disimpan\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// SALAH: Menyimpan context sebagai field struct\ntype BadProcessor struct {\n\tctx context.Context // JANGAN LAKUKAN INI\n}\n\nfunc (p *BadProcessor) Process() {\n\t// Menggunakan context yang disimpan\n\tselect {\n\tcase <-time.After(2 * time.Second):\n\t\tfmt.Println(\"Processing completed\")\n\tcase <-p.ctx.Done():\n\t\tfmt.Printf(\"Processing cancelled: %v\\n\", p.ctx.Err())\n\t}\n}\n\n// BENAR: Meneruskan context sebagai parameter\ntype GoodProcessor struct{}\n\nfunc (p *GoodProcessor) Process(ctx context.Context) {\n\tselect {\n\tcase <-time.After(2 * time.Second):\n\t\tfmt.Println(\"Processing completed\")\n\tcase <-ctx.Done():\n\t\tfmt.Printf(\"Processing cancelled: %v\\n\", ctx.Err())\n\t}\n}\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n\tdefer cancel()\n\t\n\t// Menggunakan GoodProcessor\n\tprocessor := &GoodProcessor{}\n\tprocessor.Process(ctx)\n}\n```\n\n**Notifikasi Error:** JANGAN menyimpan context sebagai field struct. Context harus diteruskan sebagai parameter ke fungsi yang membutuhkan.\n\n### b. Context Tidak Boleh Dikirim ke Channel\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// SALAH: Mengirim context ke channel\nfunc wrongWay() {\n\tctx := context.Background()\n\tch := make(chan context.Context)\n\t\n\tgo func() {\n\t\tch <- ctx // Tidak idiomatik\n\t}()\n\t\n\treceivedCtx := <-ch\n\tfmt.Println(\"Received context:\", receivedCtx)\n}\n\n// BENAR: Mengirim data melalui context atau menggunakan channel untuk sinyal\nfunc rightWay() {\n\tctx := context.Background()\n\tdone := make(chan bool)\n\t\n\tgo func() {\n\t\t// Gunakan context untuk cancellation\n\t\t// Gunakan channel untuk sinyal\n\t\tdone <- true\n\t}()\n\t\n\tselect {\n\tcase <-done:\n\t\tfmt.Println(\"Operation completed\")\n\tcase <-ctx.Done():\n\t\tfmt.Printf(\"Operation cancelled: %v\\n\", ctx.Err())\n\t}\n}\n\nfunc main() {\n\trightWay()\n}\n```\n\n**Notifikasi Error:** JANGAN mengirim context ke channel. Gunakan context untuk cancellation/deadline dan channel untuk passing data atau sinyal.\n\n### c. Lupa Cancel Context\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// LUPA memanggil cancel - menyebabkan resource leak\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t// defer cancel() // LUPA INI\n\t\n\t// Simulasi pekerjaan\n\t<-ctx.Done()\n\tfmt.Printf(\"Context finished: %v\\n\", ctx.Err())\n\t\n\t// Cancel tidak dipanggil, bisa menyebabkan resource leak\n\t// dalam aplikasi yang kompleks\n\ttime.Sleep(1 * time.Second)\n}\n```\n\n**Notifikasi Error:** SELALU panggil fungsi `cancel` yang dikembalikan oleh `WithCancel`, `WithTimeout`, atau `WithDeadline`, biasanya dengan `defer`.\n\n## 6. Best Practices\n\n1.  **Gunakan `context.Background()` sebagai root context** untuk request atau operasi utama.\n2.  **Teruskan context sebagai parameter pertama** dalam fungsi yang membutuhkan cancellation/deadline.\n3.  **Selalu panggil `cancel()`** yang dikembalikan oleh fungsi pembentuk context.\n4.  **Gunakan typed key** untuk value passing untuk menghindari collision.\n5.  **Hindari menyimpan context dalam struct**.\n6.  **Gunakan context untuk cancellation dan deadline**, bukan untuk passing data aplikasi utama.\n7.  **Periksa `ctx.Done()` secara teratur** dalam operasi lama untuk merespon cancellation.\n\n## 7. Pattern: Context dalam Database Query\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\t\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\nfunc queryWithTimeout(db *sql.DB) error {\n\t// Membuat context dengan timeout 2 detik\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel()\n\t\n\t// Query dengan context\n\trows, err := db.QueryContext(ctx, \"SELECT * FROM users WHERE active = ?\", true)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\t\n\t// Memproses hasil\n\tfor rows.Next() {\n\t\t// Memeriksa context secara teratur\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\t// Proses row\n\t\t\tvar id int\n\t\t\tvar name string\n\t\t\tif err := rows.Scan(&id, &name); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfmt.Printf(\"User: %d - %s\\n\", id, name)\n\t\t}\n\t}\n\t\n\treturn rows.Err()\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"sqlite3\", \":memory:\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\t\n\t// Membuat tabel dan data contoh\n\tdb.Exec(\"CREATE TABLE users (id INTEGER, name TEXT)\")\n\tdb.Exec(\"INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob')\")\n\t\n\tif err := queryWithTimeout(db); err != nil {\n\t\tfmt.Printf(\"Query failed: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(\"Query completed successfully\")\n\t}\n}\n```\n\n## 8. Kesimpulan\n\nContext adalah alat yang sangat penting dalam pemrograman concurrent Go. Memahami cara kerja context sangat penting untuk:\n- Membangun aplikasi yang responsif terhadap cancellation\n- Mengelola lifetime request dan sumber daya dengan baik\n- Menghindari goroutine leak\n- Membangun sistem yang scalable dan maintainable\n\nDengan memahami mekanisme, perilaku, dan best practices dari context, Anda dapat menulis aplikasi Go yang robust dan efisien, terutama dalam lingkungan server-side dan microservices.\n